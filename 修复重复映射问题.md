# 修复重复映射问题

## 问题描述

当 `outCount > 1` 时，同一个文件（如字体文件）会被混淆多次，导致映射关系混乱。即使 `outCount = 1` 时，已混淆的文件名也可能被重复混淆。

### 问题原因

1. **共享映射管理器**：所有工作目录共享同一个 `MappingManager` 实例
2. **映射累积**：每次处理工作目录时，映射关系会累积到同一个映射管理器中
3. **重复文件映射**：同一个文件在不同工作目录中被重复映射
4. **已混淆文件名重复处理**：已混淆的文件名（如 `-F62fjtqLzI2JPCgQBnw7HFow2oe2EcP5pp0erwTqsSWs9Jezazjcb4.117.woff2`）被重复混淆

### 问题表现

```
🖼️ 移动二进制文件: static/font/-F62fjtqLzI2JPCgQBnw7HFow2oe2EcP5pp0erwTqsSWs9Jezazjcb4.76.woff2 -> com_e99a09/assets_4c8f1f/asset_9dbc2dc6.woff2
✅ 二进制文件移动成功: -F62fjtqLzI2JPCgQBnw7HFow2oe2EcP5pp0erwTqsSWs9Jezazjcb4.76.woff2
📁 文件映射: static/font/-F62fjtqLzI2JPCgQBnw7HFow2oe2EcP5pp0erwTqsSWs9Jezazjcb4.76.woff2 -> com_e99a09/assets_4c8f1f/asset_9dbc2dc6.woff2

# 同一个文件被映射了两次，第二次映射覆盖了第一次
```

## 解决方案

### 1. 为每个工作目录创建独立的映射管理器

修改 `lib/obfuscation-engine.js` 中的 `run()` 方法：

```javascript
// 为每个工作目录创建独立的映射管理器
const workDirMappingManager = new MappingManager();
const workDirFileStructureObfuscator = new FileStructureObfuscator(workDirMappingManager);

// 使用独立的映射管理器处理文件
await workDirFileStructureObfuscator.process(workDir);
await this.processFiles(workDir, workDirMappingManager);
```

### 2. 修改文件处理方法签名

更新 `processFiles()` 方法，接受映射管理器参数：

```javascript
async processFiles(workDir, mappingManager) {
    // 使用传入的映射管理器而不是共享的
    content = await HtmlObfuscator.obfuscate(content, mappingManager.mappings);
    // ...
}
```

### 3. 添加已混淆文件名检测

修改 `lib/core/file-structure-obfuscator.js` 中的 `shouldRenameFile()` 方法：

```javascript
shouldRenameFile(fileName) {
    // ... 现有逻辑 ...
    
    // 检查文件名是否已经混淆过（包含随机字符串模式）
    const obfuscatedPattern = /^[a-zA-Z0-9_-]{20,}\.\d+$/;
    if (obfuscatedPattern.test(baseName)) {
        console.log(`⏭️ 跳过已混淆文件: ${fileName}`);
        return false;
    }
    
    // 检查文件名是否已经是生成的混淆格式
    const generatedPattern = /^(file|mod|comp|item|data|core|res|asset)_[a-f0-9]{8}$/;
    if (generatedPattern.test(baseName)) {
        console.log(`⏭️ 跳过已生成混淆文件: ${fileName}`);
        return false;
    }
    
    // ... 其余逻辑 ...
}
```

### 4. 更新文件名生成逻辑

修改 `generateObfuscatedFileName()` 方法：

```javascript
generateObfuscatedFileName(originalName, extension) {
    // ... 现有逻辑 ...
    
    // 检查文件名是否已经混淆过
    const obfuscatedPattern = /^[a-zA-Z0-9_-]{20,}\.\d+$/;
    if (obfuscatedPattern.test(baseName)) {
        console.log(`⏭️ 保持已混淆文件名: ${originalName}`);
        return originalName;
    }
    
    // 检查文件名是否已经是生成的混淆格式
    const generatedPattern = /^(file|mod|comp|item|data|core|res|asset)_[a-f0-9]{8}$/;
    if (generatedPattern.test(baseName)) {
        console.log(`⏭️ 保持已生成混淆文件名: ${originalName}`);
        return originalName;
    }
    
    // ... 生成新文件名的逻辑 ...
}
```

## 修复效果

### 修复前
- 所有工作目录共享同一个映射管理器
- 同一个文件可能被映射多次
- 映射关系混乱，难以追踪
- 已混淆的文件名被重复混淆

### 修复后
- 每个工作目录有独立的映射管理器
- 每个文件在每个工作目录中只被映射一次
- 映射关系清晰，便于调试和追踪
- 已混淆的文件名被正确识别并跳过

## 验证方法

1. 运行混淆器，设置 `outCount > 1`
2. 检查生成的映射文件 `obfuscation-mapping_*.json`
3. 确认每个文件在每个工作目录中只出现一次映射
4. 验证不同工作目录中的映射关系是独立的
5. 运行测试脚本验证已混淆文件名检测：

```bash
node test-obfuscated-filename.js
```

## 相关文件

- `lib/obfuscation-engine.js` - 主要修复文件
- `lib/core/file-structure-obfuscator.js` - 文件结构混淆器
- `lib/utils/mapping-manager.js` - 映射管理器
- `test-obfuscated-filename.js` - 文件名检测测试脚本
- `验证修复.js` - 映射文件验证脚本

## 注意事项

1. 修复后，每个工作目录的映射关系是独立的
2. 不同工作目录中，同一个文件可能被映射到不同的路径
3. 这是正常行为，因为每个工作目录都是独立的混淆结果
4. 已混淆的文件名会被正确识别并保持原样
5. 如果需要保持映射关系一致，可以考虑在映射管理器中添加一致性检查 